%{
  #define YYDEBUG 1
  
  #include <iostream>

  #include "Values.h"
  #include "instruction.h"
  #include "defines.h"
  
  #include "lex.yy.h"

	//extern "C"
	//{
    int yyparse(void);
    extern int yylex(void);  
    //int cyywrap();
    /*{
     return 1;
     }*/
    void yyerror(const char *s);

    Code *assemble(const char *string);
    Code *code;
	//}
  
%}

%union
{
	Value *v;
  Instruction *i;
  struct InstructionTree *il;
  struct ValueTree *vl;
  struct ValuePairTree *vpl;
  struct LambdaIntPair *lip;
  struct Code *code;
  Opcode op;
}

%token T_EOL

%token T_DOLLAR T_PERCENT T_SEMICOL T_COMMA T_RISE T_SINK

%token T_LPAREN T_RPAREN T_LBRACE T_RBRACE T_LBRACK T_RBRACK

%token T_PLUS T_MINUS T_DIVIDE T_TIMES
%token T_DDIVIDE
%token T_AND T_OR T_NOT T_RSHIFT T_LSHIFT T_UNDERSCORE

%token T_PLUS_MON T_PLUS_DIA T_MINUS_MON T_MINUS_DIA T_TIMES_MON T_TIMES_DIA T_DIVIDE_MON T_DIVIDE_DIA
%token T_RAND T_SORT T_SHUFFLE

%token T_AT T_HASH T_AT_FRONT T_HASH_FRONT T_AT_BACK T_HASH_BACK

%token T_MAP T_FOLD T_DMAP T_ITER T_ITERI T_ANY T_EVERY T_CARTESIAN

%token T_EQUAL T_LESSER T_GREATER

%token T_PERIOD T_COLON T_BANG T_DBANG T_QUESTION T_DQUESTION T_PEEK

%token T_RECUR T_RECURV T_WHILE

%token T_I T_S

%token T_OPCODE

%token INTEGER FLOAT BOOLEAN CHARACTER STRING RANGE STRING_LITERAL

%type<v> INTEGER FLOAT BOOLEAN CHARACTER RANGE
%type<v> STRING STRING_LITERAL
%type<v> lambda lazy_array opt_value

%type<il> instructions;
%type<i> instruction;
%type<vl> values;
%type<v> value;
%type<lip> lazy_pairs;
%type<vpl> value_pairs;

%type<code> start;

%type<op> sinstruction T_OPCODE

%%

start:
  instructions { if ($1) code = $1->assemble(); }
;

instructions:
  { $$ = NULL; }
  | instructions instruction { $$ = new InstructionTree($2, $1); }
;

instruction:
  value { $$ = new PushInstruction($1); }
  | T_PLUS { $$ = new OpcodeInstruction(OP_PLUS); }
  | T_MINUS { $$ = new OpcodeInstruction(OP_MINUS); }
  | T_DIVIDE { $$ = new OpcodeInstruction(OP_DIVIDE); }
  | T_TIMES { $$ = new OpcodeInstruction(OP_TIMES); }

  | T_DDIVIDE { $$ = new OpcodeInstruction(OP_MOD); }

  | T_UNDERSCORE { $$ = new OpcodeInstruction(OP_NEG); }

  | T_RSHIFT { $$ = new OpcodeInstruction(OP_RSHIFT); }
  | T_LSHIFT { $$ = new OpcodeInstruction(OP_LSHIFT); }
  | T_AND { $$ = new OpcodeInstruction(OP_AND); }
  | T_OR { $$ = new OpcodeInstruction(OP_OR); }
  | T_NOT { $$ = new OpcodeInstruction(OP_NOT); }
  
  | T_RAND { $$ = new OpcodeInstruction(OP_RAND); }
  | T_SORT { $$ = new OpcodeInstruction(OP_SORT); }
  | T_SHUFFLE { $$ = new OpcodeInstruction(OP_SHUFFLE); }
  
  | T_PLUS_MON { $$ = new OpcodeInstruction(OP_PLUS_MON); }
  | T_PLUS_DIA { $$ = new OpcodeInstruction(OP_PLUS_DIA); }
  | T_MINUS_MON { $$ = new OpcodeInstruction(OP_MINUS_MON); }
  | T_MINUS_DIA { $$ = new OpcodeInstruction(OP_MINUS_DIA); }
  | T_TIMES_MON { $$ = new OpcodeInstruction(OP_TIMES_MON); }
  | T_TIMES_DIA { $$ = new OpcodeInstruction(OP_TIMES_DIA); }
  | T_DIVIDE_MON { $$ = new OpcodeInstruction(OP_DIVIDE_MON); }
  | T_DIVIDE_DIA { $$ = new OpcodeInstruction(OP_DIVIDE_DIA); }

  | T_BANG { $$ = new OpcodeInstruction(OP_BANG); }
  | T_DBANG { $$ = new OpcodeInstruction(OP_DBANG); }
  | T_QUESTION { $$ = new OpcodeInstruction(OP_QUESTION); }
  | T_DQUESTION { $$ = new OpcodeInstruction(OP_DQUESTION); }

  | T_DOLLAR { $$ = new OpcodeInstruction(OP_DUPE); }
  | T_PERCENT { $$ = new OpcodeInstruction(OP_SWAP); }
  | T_SEMICOL { $$ = new OpcodeInstruction(OP_DROP); }
  | T_COMMA { $$ = new OpcodeInstruction(OP_PICK); }
  | T_RISE { $$ = new OpcodeInstruction(OP_RISE); }
  | T_SINK { $$ = new OpcodeInstruction(OP_SINK); }


  | T_EQUAL { $$ = new OpcodeInstruction(OP_EQUAL); }
  | T_LESSER { $$ = new OpcodeInstruction(OP_LESSER); }
  | T_GREATER { $$ = new OpcodeInstruction(OP_GREATER); }
  
  | T_PEEK { $$ = new OpcodeInstruction(OP_PEEK); }
  
  | T_AT { $$ = new OpcodeInstruction(OP_AT); }
  | T_HASH { $$ = new OpcodeInstruction(OP_HASH); }
  | T_AT_FRONT { $$ = new OpcodeInstruction(OP_AT_FRONT); }
  | T_HASH_FRONT { $$ = new OpcodeInstruction(OP_HASH_FRONT); }
  | T_AT_BACK { $$ = new OpcodeInstruction(OP_AT_BACK); }
  | T_HASH_BACK { $$ = new OpcodeInstruction(OP_HASH_BACK); }
  

  | T_MAP { $$ = new OpcodeInstruction(OP_MAP); }
  | T_FOLD { $$ = new OpcodeInstruction(OP_FOLD); }
  | T_DMAP { $$ = new OpcodeInstruction(OP_DMAP); }
  | T_CARTESIAN { $$ = new OpcodeInstruction(OP_CARTESIAN); }
  | T_ITER { $$ = new OpcodeInstruction(OP_ITER); }
  | T_ITERI { $$ = new OpcodeInstruction(OP_ITERI); }

  | T_S { $$ = new OpcodeInstruction(OP_STRING_CAST); }

  | T_ANY { $$ = new OpcodeInstruction(OP_ANY); }
  | T_EVERY { $$ = new OpcodeInstruction(OP_EVERY); }

  | T_RECUR { $$ = new OpcodeInstruction(OP_RECUR); }
  | T_RECURV { $$ = new OpcodeInstruction(OP_RECURV); }
  | T_WHILE { $$ = new OpcodeInstruction(OP_WHILE); }
  
  | sinstruction { $$ = new OpcodeInstruction($1); }
;

sinstruction:
  T_OPCODE { $$ = $1; }
;


values:
  value { $$ = new ValueTree($1,NULL); }
  | values value { $$ = new ValueTree($2, $1); }
; 

value_pairs:
  value T_COLON value { $$ = new ValuePairTree($1, $3, NULL); }
  | value_pairs value T_COLON value { $$ = new ValuePairTree($2, $4, $1); }
;

lazy_pairs:
  { $$ = NULL; };
  | lazy_pairs INTEGER T_COLON lambda { $$ = new LambdaIntPair(((Int*)$2)->get(), (Lambda*)$4, $1) };
;

lazy_array:
  T_LPAREN T_QUESTION lazy_pairs lambda T_RPAREN {
    LazyArrayHolder holder((Lambda*)$4, false);
    
    LambdaIntPair *lip = $3;
    while (lip) {
      holder.addMap(lip->i, lip->code);
      lip = lip->n;
    }
    
    $$ = new LazyArray(holder);
  }
  | T_LPAREN T_QUESTION T_I lazy_pairs lambda T_RPAREN {
  LazyArrayHolder holder((Lambda*)$5, true);
  
  LambdaIntPair *lip = $4;
  while (lip) {
    holder.addMap(lip->i, lip->code);
    lip = lip->n;
  }
  
  $$ = new LazyArray(holder);
}

opt_value:
  { $$ = NULL; }
  | value { $$ = $1; }
;  

value:
  INTEGER { $$ = $1; }
  | FLOAT { $$ = $1; }
  | BOOLEAN { $$ = $1; }
  | CHARACTER { $$ = $1; }
  | STRING_LITERAL { $$ = $1; }
  | RANGE { $$ = $1; }
  
  | T_LBRACE values T_RBRACE { $$ = new List($2->assemble()); }
  | T_LBRACE T_RBRACE { $$ = new List(); }
  
  | T_LBRACE T_GREATER values T_RBRACE { $$ = new Stack($3->assemble()); }
  | T_LBRACE T_GREATER T_RBRACE { $$ = new Stack(); }
  
  | T_LBRACE T_LESSER values T_RBRACE { $$ = new Queue($3->assemble()); }
  | T_LBRACE T_LESSER T_RBRACE { $$ = new Queue(); }
  
  | T_LBRACE T_PERIOD values T_RBRACE {
        list<Value*>* vs = $3->assemble();
        $$ = new Set(new unordered_set<Value*>(vs->begin(),vs->end()));
    }
  | T_LBRACE T_PERIOD T_RBRACE { $$ = new Set(); }
      
  | T_LBRACE value_pairs T_RBRACE { $$ = new Map($2->assemble()) }
  | T_LBRACE T_COLON T_RBRACE { $$ = new Map(); }


  | T_LPAREN values T_RPAREN { list<Value*>* vs = $2->assemble(); $$ = new Array(new vector<Value*>(vs->begin(),vs->end())); }
  | T_LPAREN T_COLON INTEGER opt_value T_RPAREN { $$ = new Array(((Int*)$3)->get(), $4); }
  | T_LPAREN T_RPAREN { $$ = new Array(); }
  
  | lazy_array { $$ = $1; }
  | lambda { $$ = $1; }
;
    
lambda:
    T_LBRACK instructions T_RBRACK { $$ = new Lambda($2->assemble()); }
;

%%

Code* assemble(const char *string)
{
  //yydebug = 1;
  
  code = NULL;
  
  YY_BUFFER_STATE state = yy_scan_string(string);
  yyparse();
  yy_delete_buffer(state);


  return code;
}

void yyerror(const char *s)
{
	//failed = true;
	cout << "[ASSEMBLER] Parse error: " << s << endl;
}
